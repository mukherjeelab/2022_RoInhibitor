---
title: "Fig1_AldoChart"
author: "Kathryn Walters"
date: "7/8/2022"
output: html_document
---

```{r setup, include=TRUE, echo=TRUE, warning=FALSE, message=FALSE}

library(drc) # modeling tools
library(tidyverse) # your go to set of functions for messing w/data
library(RColorBrewer) # to make color schemes
#library(ggpubr) # publication quality ggplots ha ha ha
library(ggthemes) # additional themes for ggplot-ing
library(gridExtra) # allows arranging of plots (rows/columns...)
library(splitstackshape)
library(ggpubr)
library(here)

```

```{r function, message=FALSE, warning=FALSE, include=TRUE}

ELISAmodelfit <- function(OD) {
## ELISA model fit
#Fit a 4-parameter model from the standard curve in order to identify the correct paramaters of a formula to convert fluorescence to aldosterone concentrations.
# Subtract background signal (measured at 540nm) from target signal (measured at 450nm)
OD$corrected <- OD$OD_450 - OD$OD_540

standards <- OD %>% filter(grepl("std", Sample)) # one way of creating a new tibble that only contains your standards

nsb <- OD %>% filter(grepl("nsb", Sample)) # one way of creating a new tibble that only contains your NSBs

# create a tibble for the actual concentrations by std name -> this has conc for aldosterone kit.
stdcrvdata <- data.frame(
  Sample=paste0("std",rep(seq(1,7,1),each=2)),
  known=rep(c(4000,1000,250,62.25,15.625,3.906,0),each=2)
  )

# sort standards by name to match the order of 'stdcrvdata' data.
standards <- standards %>% arrange(Sample) %>% dplyr::select(c(Sample,corrected))

# sort stdcrvdata by name to match the order of 'standards' data.
stdcrvdata <- stdcrvdata %>% arrange(Sample)

# combine them together
stdcrvdata <- data.frame(standards,expected=stdcrvdata$known)
colnames(stdcrvdata)[2] <- "measured"

# take out zeros
stdcrvdata <- stdcrvdata %>% filter(expected > 0)
stdcrvdata$logconc <-log10(stdcrvdata$expected)# log10 from conc

# plot(stdcrvdata$logconc, stdcrvdata$measured)
# model the standard curve using generated points.  plot those points in red.
fit <- drm(formula =   measured ~ logconc , data = stdcrvdata, fct = LL.4())
summary(fit)

# This is a description of the variables and terms defined in the 'fit' model.
# x = the independent variable (Absorbance) (Concentration, estimated from the Absorbance)
# y = the dependent variable 
# The 4 estimated parameters consist of the following:

# the minimum value that can be obtained. (this is the ABS at conc. 0)
# a = fit$coefficients[2] 
# d = the maximum value that can be obtained (i.e. what happens at infinite dose)
# c = the point of inflection (i.e. the point on the S shaped curve halfway between a and d)
# b = Hillâ€™s slope of the curve (i.e. this is related to the steepness of the curve at point c).

# Generate points from  model. Pick range from logconc
x <- seq(from = 0, to = 4, length=100)

# from OD ~ d + (a - d)/(1 + (logconc/cc)^b)
y <- (fit$coefficients[2]+ (fit$coefficients[3]- fit$coefficients[2])/(1+(x/fit$coefficients[4])^ fit$coefficients[1])) 
# remove standards and NSB wells leaving only experimental measurements
OD <- OD %>% filter(!grepl("std|nsb", Sample))

# here we are applying the equation described in ELISAmodelfit function to...
OD$loganswer<- fit$coefficients[4]*(
  (
    (-1* fit$coefficients[3]+ OD$corrected)/
      (fit$coefficients[2]-OD$corrected))^(1/ fit$coefficients[1])
  )

OD$conc <- 10^OD$loganswer

OD$below <- OD$conc < min(stdcrvdata$expected)
OD$above <- OD$conc > max(stdcrvdata$expected)

plot(x = stdcrvdata$logconc, y = stdcrvdata$measured, main="log standard curve",
  xlim = c(min(x),max(x)),
  ylim = c(min(y),max(y))
     )
lines(x,y, lty="dotted", col="red")
lines(OD$loganswer, OD$corrected, type="points", col="blue")

OD$Sample <- gsub(pattern = "mediaOnly", replacement = "media_NA", x = OD$Sample)

OD <- separate(data = OD, col = Sample, into = c("tx","stim"), sep = "_")

OD$stim <- relevel(factor(OD$stim), ref = "unstim")
OD$tx <- relevel(factor(OD$tx), ref = "DMSO")

bg <- OD %>% filter(tx=="media") %>% summarise(mean(na.omit(conc))) %>% pull()
OD$conc <- OD$conc - bg

OD <- OD %>% filter(tx!="media")
OD$tx <- gsub(x = OD$tx, pattern = "uM", replacement = "")
levels(factor(OD$tx))
OD$tx <- factor(OD$tx, levels = c("DMSO","0.1", "0.5", "1", "2.5", "5","10","20","50","100"))

OD$Ro_conc <- as.numeric(gsub("DMSO","0", OD$tx))

names(OD)[7] <- "PB_24"

#write_csv(x = OD, path = "data/output/"OD".csv")

return(OD)
}

```




```{r read data, include=TRUE, warning=FALSE, message=FALSE}

# Read in first set of data files. OD is ELISA file. PB is presto blue file. FR is fluroreporter file - this first experiment doesn't have any FR data. 
OD1 <- read_csv(here("data", "20190719_Ro08-2750Titration_ELISA.csv"))
colnames(OD1) <- c("Sample","Well","OD_450","OD_540","OD_570")

pb1 <- read_csv(here("data", "20190718_Ro08-2750Titration_PB1.csv"))[,2:3]
colnames(pb1)[2] <- c("viability_24")

# join presto blue measurements with ELISA measurements
OD1 <- left_join(OD1, pb1, by = "Well")
OD1$FR_24 <- rep(NA,nrow(OD1))



# Read in second set of data files. OD is ELISA file. PB is presto blue file. FR is fluroreporter file. 
OD2 <- read_csv(here("data", "20200131_Ro08-2750Titration_ELISA.csv"))
colnames(OD2) <- c("Sample","Well","OD_450","OD_540","OD_570")

pb2 <- read_csv(here("data", "20200130_Ro08-2750Titration_PB1.csv"))[,2:3]
colnames(pb2)[2] <- c("viability_24")

fr2 <- read_csv(here("data", "20200131_Ro08-2750Titration_FR.csv"))
colnames(fr2) <- c("Sample","Well","FR_24")

# join presto blue and fluorReporter measurements with ELISA measurements
OD2 <- left_join(OD2, pb2, by = "Well")
OD2 <- left_join(OD2, fr2[,-1], by = "Well")


# Read in third set of data files. OD is ELISA file. PB is presto blue file. FR is fluroreporter file. 
OD3 <- read_csv(here("data", "20200305_Ro08-2750Titration_ELISA.csv"))
colnames(OD3) <- c("Sample","Well","OD_450","OD_540","OD_570")

pb3 <- read_csv(here("data", "20200304_Ro08-2750Titration_PB1.csv"))[,2:3]
colnames(pb3)[2] <- c("viability_24")

fr3 <- read_csv(here("data", "20200305_Ro08-2750Titration_FR.csv"))
colnames(fr3) <- c("Sample","Well","FR_24")

# join presto blue measurements with ELISA measurements
OD3 <- left_join(OD3, pb3, by = "Well")
OD3 <- left_join(OD3, fr3[,-1], by = "Well")

```


```{r ELISA modeling, include=TRUE, warning=FALSE, message=FALSE}
OD1 <- ELISAmodelfit(OD1)
OD1$batch <- rep("A",nrow(OD1))

OD2 <- ELISAmodelfit(OD2)
OD2$batch <- rep("B",nrow(OD2))

OD3 <- ELISAmodelfit(OD3)
OD3$batch <- rep("C",nrow(OD3))
```



```{r stimdata, include=TRUE, warning=FALSE, message=FALSE}
#combing everything into one dataframe. 
allData <- bind_rows(OD1, OD2, OD3)


stimData <- allData %>% filter(stim=="stim")
dmso_A_aldo <- stimData %>% filter(batch=="A" & Ro_conc==0) %>% select(conc) %>% summarise(mean(conc)) %>% pull()
dmso_B_aldo <- stimData %>% filter(batch=="B" & Ro_conc==0) %>% select(conc) %>% summarise(mean(conc)) %>% pull()
dmso_C_aldo <- stimData %>% filter(batch=="C" & Ro_conc==0) %>% select(conc) %>% summarise(mean(conc)) %>% pull()

tmp <- mutate(stimData, pAldo = ifelse(batch == "A", 100*conc/dmso_A_aldo, 
                                       ifelse(batch == "B", 100*conc/dmso_B_aldo,
                                              ifelse(batch == "C", 100*conc/dmso_C_aldo, ""))
                                       )
              )
tmp$pAldo <- as.numeric(tmp$pAldo)


dmso_A_PB <- stimData %>% filter(batch=="A" & Ro_conc==0) %>% select(PB_24) %>% summarise(mean(PB_24)) %>% pull()
dmso_B_PB <- stimData %>% filter(batch=="B" & Ro_conc==0) %>% select(PB_24) %>% summarise(mean(PB_24)) %>% pull()
dmso_C_PB <- stimData %>% filter(batch=="C" & Ro_conc==0) %>% select(PB_24) %>% summarise(mean(PB_24)) %>% pull()

tmp <- mutate(tmp, pPB = ifelse(batch == "A", 100*PB_24/dmso_A_PB, 
                                       ifelse(batch == "B", 100*PB_24/dmso_B_PB,
                                              ifelse(batch == "C", 100*PB_24/dmso_C_PB, ""))
                                       )
              )
tmp$pPB <- as.numeric(tmp$pPB)

dmso_B_FR <- stimData %>% filter(batch=="B" & Ro_conc==0) %>% select(FR_24) %>% summarise(mean(FR_24)) %>% pull()
dmso_C_FR <- stimData %>% filter(batch=="C" & Ro_conc==0) %>% select(FR_24) %>% summarise(mean(FR_24)) %>% pull()


tmp <- mutate(tmp, pFR = ifelse(batch == "C", 100*FR_24/dmso_C_FR, 
                                       ifelse(batch == "B", 100*FR_24/dmso_B_FR,
                                              ifelse(batch == "A", NA, NA))
                                       )
              )


```


```{r unstim data, include=TRUE, warning=FALSE, message=FALSE}

unstimData <- allData %>% filter(stim=="unstim")
dmso_A_aldo_us <- unstimData %>% filter(batch=="A" & Ro_conc==0) %>% select(conc) %>% summarise(mean(conc)) %>% pull()
dmso_B_aldo_us <- unstimData %>% filter(batch=="B" & Ro_conc==0) %>% select(conc) %>% summarise(mean(conc)) %>% pull()
dmso_C_aldo_us <- unstimData %>% filter(batch=="C" & Ro_conc==0) %>% select(conc) %>% summarise(mean(conc)) %>% pull()

tmp_us <- mutate(unstimData, pAldo = ifelse(batch == "A", 100*conc/dmso_A_aldo_us, 
                                       ifelse(batch == "B", 100*conc/dmso_B_aldo_us,
                                              ifelse(batch == "C", 100*conc/dmso_C_aldo_us, ""))
                                       )
              )
tmp_us$pAldo <- as.numeric(tmp_us$pAldo)


dmso_A_PB_us <- unstimData %>% filter(batch=="A" & Ro_conc==0) %>% select(PB_24) %>% summarise(mean(PB_24)) %>% pull()
dmso_B_PB_us <- unstimData %>% filter(batch=="B" & Ro_conc==0) %>% select(PB_24) %>% summarise(mean(PB_24)) %>% pull()
dmso_C_PB_us <- unstimData %>% filter(batch=="C" & Ro_conc==0) %>% select(PB_24) %>% summarise(mean(PB_24)) %>% pull()

tmp_us <- mutate(tmp_us, pPB = ifelse(batch == "A", 100*PB_24/dmso_A_PB_us, 
                                       ifelse(batch == "B", 100*PB_24/dmso_B_PB_us,
                                              ifelse(batch == "C", 100*PB_24/dmso_C_PB_us, ""))
                                       )
              )
tmp_us$pPB <- as.numeric(tmp_us$pPB)

dmso_B_FR_us <- unstimData %>% filter(batch=="B" & Ro_conc==0) %>% select(FR_24) %>% summarise(mean(FR_24)) %>% pull()
dmso_C_FR_us <- unstimData %>% filter(batch=="C" & Ro_conc==0) %>% select(FR_24) %>% summarise(mean(FR_24)) %>% pull()


tmp_us <- mutate(tmp_us, pFR = ifelse(batch == "C", 100*FR_24/dmso_C_FR_us, 
                                       ifelse(batch == "B", 100*FR_24/dmso_B_FR_us,
                                              ifelse(batch == "A", NA, NA))
                                       )
              )

```



```{r plots, echo=FALSE, include=TRUE, warning=FALSE, message=FALSE}

p_Aldo_per <- ggline(tmp, x = "Ro_conc", y = "pAldo", ylab = "% Aldosterone", add = "mean_sd", xlab = "[Ro] uM") + rremove("legend") + rotate_x_text(60) + geom_hline(yintercept = 100, linetype = "dotted", color = "grey")
p_Aldo_per <- p_Aldo_per + ylim(0,120)

p_PB_per <- ggline(tmp, x = "Ro_conc", y = "pPB", ylab = "% Viability", add = "mean_sd", xlab = "[Ro] uM") + rremove("legend") + rotate_x_text(60) + geom_hline(yintercept = 100, linetype = "dotted", color = "grey")

p_PB_per <- p_PB_per + ylim(0,120)

p_FR_per <- ggline(tmp, x = "Ro_conc", y = "pFR", ylab = "% DNA", add = "mean_sd", xlab = "[Ro] uM") + rremove("legend") + rotate_x_text(60) + geom_hline(yintercept = 100, linetype = "dotted", color = "grey")

p_FR_per <- p_FR_per + ylim(0,120)

p_all_PR <- cowplot::plot_grid(
  p_Aldo_per + theme(legend.position="none"),
  p_PB_per + theme(legend.position="none"),
  p_FR_per + theme(legend.position="none"),
  align = 'vh',
  #labels = c("A", "B","C"),
  hjust = -1,
  nrow = 1
  )

p_all_PR
#ggsave(plot = p_all_PR, filename = "./plots/all_percent_sd.pdf", width = 12, height = 3)


#Fit for pAldo
fit <- drm(formula =   pAldo ~ Ro_conc , data = tmp, fct = LL.4())
summary(fit)

# This is a description of the variables and terms defined in the 'fit' model.
# x = the independent variable (percent aldo?)
# y = the dependent variable 
# The 4 estimated parameters consist of the following:
# the minimum value that can be obtained. (this is the ABS at conc. 0)
# a = fit$coefficients[2] 
# d = the maximum value that can be obtained (i.e. what happens at infinite dose)
# c = the point of inflection (i.e. the point on the S shaped curve halfway between a and d)
# b = Hillâ€™s slope of the curve (i.e. this is related to the steepness of the curve at point c).
# Generate points from  model. Pick range from logconc
x <- seq(from = 0, to = 100, length=100)
# from OD ~ d + (a - d)/(1 + (logconc/cc)^b)
y <- (fit$coefficients[2]+ (fit$coefficients[3]- fit$coefficients[2])/(1+(x/fit$coefficients[4])^ fit$coefficients[1])) 

plot(x = tmp$Ro_conc, y = tmp$pAldo, main="log standard curve") 
lines(x,y, lty="dotted", col="red") 


#Fit for pPB
fit <- drm(formula =   pPB ~ Ro_conc , data = tmp, fct = LL.4())
summary(fit)

# This is a description of the variables and terms defined in the 'fit' model.
# x = the independent variable (percent aldo?)
# y = the dependent variable 
# The 4 estimated parameters consist of the following:
# the minimum value that can be obtained. (this is the ABS at conc. 0)
# a = fit$coefficients[2] 
# d = the maximum value that can be obtained (i.e. what happens at infinite dose)
# c = the point of inflection (i.e. the point on the S shaped curve halfway between a and d)
# b = Hillâ€™s slope of the curve (i.e. this is related to the steepness of the curve at point c).
# Generate points from  model. Pick range from logconc
x <- seq(from = 0, to = 100, length=100)
# from OD ~ d + (a - d)/(1 + (logconc/cc)^b)
y <- (fit$coefficients[2]+ (fit$coefficients[3]- fit$coefficients[2])/(1+(x/fit$coefficients[4])^ fit$coefficients[1])) 

plot(x = tmp$Ro_conc, y = tmp$pPB, main="log standard curve") 
lines(x,y, lty="dotted", col="red") 


#Fit for pFR
fit <- drm(formula =   pFR ~ Ro_conc , data = tmp, fct = LL.4())
summary(fit)

# This is a description of the variables and terms defined in the 'fit' model.
# x = the independent variable (percent aldo?)
# y = the dependent variable 
# The 4 estimated parameters consist of the following:
# the minimum value that can be obtained. (this is the ABS at conc. 0)
# a = fit$coefficients[2] 
# d = the maximum value that can be obtained (i.e. what happens at infinite dose)
# c = the point of inflection (i.e. the point on the S shaped curve halfway between a and d)
# b = Hillâ€™s slope of the curve (i.e. this is related to the steepness of the curve at point c).
# Generate points from  model. Pick range from logconc
x <- seq(from = 0, to = 100, length=100)
# from OD ~ d + (a - d)/(1 + (logconc/cc)^b)
y <- (fit$coefficients[2]+ (fit$coefficients[3]- fit$coefficients[2])/(1+(x/fit$coefficients[4])^ fit$coefficients[1])) 

plot(x = tmp$Ro_conc, y = tmp$pFR, main="log standard curve") 
lines(x,y, lty="dotted", col="red") 
```


```{r}
p_Aldo_per_us <- ggline(tmp_us, x = "Ro_conc", y = "pAldo", ylab = "% Aldosterone", add = "mean_sd", xlab = "[Ro] uM") + rremove("legend") + rotate_x_text(60) + geom_hline(yintercept = 100, linetype = "dotted", color = "grey")
p_Aldo_per_us <- p_Aldo_per_us + ylim(0,300)

p_PB_per_us <- ggline(tmp_us, x = "Ro_conc", y = "pPB", ylab = "% Viability", add = "mean_sd", xlab = "[Ro] uM") + rremove("legend") + rotate_x_text(60) + geom_hline(yintercept = 100, linetype = "dotted", color = "grey")

p_PB_per_us <- p_PB_per_us + ylim(0,300)

p_FR_per_us <- ggline(tmp_us, x = "Ro_conc", y = "pFR", ylab = "% DNA", add = "mean_sd", xlab = "[Ro] uM") + rremove("legend") + rotate_x_text(60) + geom_hline(yintercept = 100, linetype = "dotted", color = "grey")

p_FR_per_us <- p_FR_per_us + ylim(0,300)

p_all_PR_us <- cowplot::plot_grid(
  p_Aldo_per_us + theme(legend.position="none"),
  p_PB_per_us + theme(legend.position="none"),
  p_FR_per_us + theme(legend.position="none"),
  align = 'vh',
  #labels = c("A", "B","C"),
  hjust = -1,
  nrow = 1
  )

p_all_PR_us
#ggsave(plot = p_all_PR, filename = "./plots/all_percent_sd.pdf", width = 12, height = 3)


#Fit for pAldo
fit <- drm(formula =   pAldo ~ Ro_conc , data = tmp_us, fct = LL.4())
summary(fit)

# This is a description of the variables and terms defined in the 'fit' model.
# x = the independent variable (percent aldo?)
# y = the dependent variable 
# The 4 estimated parameters consist of the following:
# the minimum value that can be obtained. (this is the ABS at conc. 0)
# a = fit$coefficients[2] 
# d = the maximum value that can be obtained (i.e. what happens at infinite dose)
# c = the point of inflection (i.e. the point on the S shaped curve halfway between a and d)
# b = Hillâ€™s slope of the curve (i.e. this is related to the steepness of the curve at point c).
# Generate points from  model. Pick range from logconc
x <- seq(from = 0, to = 100, length=100)
# from OD ~ d + (a - d)/(1 + (logconc/cc)^b)
y <- (fit$coefficients[2]+ (fit$coefficients[3]- fit$coefficients[2])/(1+(x/fit$coefficients[4])^ fit$coefficients[1])) 

plot(x = tmp_us$Ro_conc, y = tmp_us$pAldo, main="log standard curve") 
lines(x,y, lty="dotted", col="red") 


#Fit for pPB
fit <- drm(formula =   pPB ~ Ro_conc , data = tmp_us, fct = LL.4())
summary(fit)

# This is a description of the variables and terms defined in the 'fit' model.
# x = the independent variable (percent aldo?)
# y = the dependent variable 
# The 4 estimated parameters consist of the following:
# the minimum value that can be obtained. (this is the ABS at conc. 0)
# a = fit$coefficients[2] 
# d = the maximum value that can be obtained (i.e. what happens at infinite dose)
# c = the point of inflection (i.e. the point on the S shaped curve halfway between a and d)
# b = Hillâ€™s slope of the curve (i.e. this is related to the steepness of the curve at point c).
# Generate points from  model. Pick range from logconc
x <- seq(from = 0, to = 100, length=100)
# from OD ~ d + (a - d)/(1 + (logconc/cc)^b)
y <- (fit$coefficients[2]+ (fit$coefficients[3]- fit$coefficients[2])/(1+(x/fit$coefficients[4])^ fit$coefficients[1])) 

plot(x = tmp_us$Ro_conc, y = tmp_us$pPB, main="log standard curve") 
lines(x,y, lty="dotted", col="red") 


#Fit for pFR
fit <- drm(formula =   pFR ~ Ro_conc , data = tmp_us, fct = LL.4())
summary(fit)

# This is a description of the variables and terms defined in the 'fit' model.
# x = the independent variable (percent aldo?)
# y = the dependent variable 
# The 4 estimated parameters consist of the following:
# the minimum value that can be obtained. (this is the ABS at conc. 0)
# a = fit$coefficients[2] 
# d = the maximum value that can be obtained (i.e. what happens at infinite dose)
# c = the point of inflection (i.e. the point on the S shaped curve halfway between a and d)
# b = Hillâ€™s slope of the curve (i.e. this is related to the steepness of the curve at point c).
# Generate points from  model. Pick range from logconc
x <- seq(from = 0, to = 100, length=100)
# from OD ~ d + (a - d)/(1 + (logconc/cc)^b)
y <- (fit$coefficients[2]+ (fit$coefficients[3]- fit$coefficients[2])/(1+(x/fit$coefficients[4])^ fit$coefficients[1])) 

plot(x = tmp_us$Ro_conc, y = tmp_us$pFR, main="log standard curve") 
lines(x,y, lty="dotted", col="red") 
```


